# runscript Execution Specification

## 1. Overview

`runscript` executes a script according to metadata encoded in a header block
immediately following the shebang. It constructs:

- argv[] — argument vector
- envp[] — environment vector

and performs a single execve() of the target executable.

Evaluation is deterministic, single‑pass, and non‑recursive.

---

## 2. Script Format

### 2.1 Shebang

The first line must be:

    #!/usr/bin/runscript <executable>

`<executable>` becomes argv[0].

### 2.2 Header Block

All immediately following lines beginning with:

    #!

are header lines. The header ends at the first non‑`#!` line.

---

## 3. Header Line Grammar

Each header line has the form:

    #!<metachars><body>

Where:

- `<metachars>` is zero or more characters from: `=`, `$`, `\`, `!`
- `<body>` is the remainder of the line after stripping leading whitespace

Meta‑characters modify interpretation of `<body>`.

---



## 4. Meta‑character Semantics

### 4.1 `!` — literal mode

If `!` appears in `<metachars>`, **all special interpretation is disabled**:

- no escape processing
- no `${…}` substitution
- no binding detection
- `<body>` becomes a literal positional argument

`!` overrides all other meta‑characters.

### 4.2 `\` — disable escapes

If `\` appears in `<metachars>`, escape processing is disabled.

### 4.3 `$` — disable substitution

If `$` appears in `<metachars>`, `${…}` sequences are literal.

### 4.4 `=` — disable binding detection

If `=` appears in `<metachars>`, the line is treated as a positional argument even if it contains `=` or `:=`.

---

## 5. Escape Processing

Performed first unless disabled by `\` or `!`.

Recognised escapes:

- `\\` → `\`
- `\n` → newline
- `\r` → carriage return
- `\t` → tab
- `\s` → space
- `\$` → `$`
- `\${` → `${`
- `\}` → `}`

Unrecognised escapes become literal.

---

## 6. Substitution Processing

Performed after escapes unless disabled by `$` or `!`.

### 6.1 Environment substitution

`${NAME}` expands to the value of environment variable NAME.

Undefined NAME → **fatal error**.

### 6.2 Script name substitution

`${}` expands to the script filename.

### 6.3 Single‑pass rule

Substitution is **not recursive**. If expansion produces `${…}`, it remains literal.

---

## 7. Classification

After escapes and substitution:

### 7.1 Conditional binding

    NAME:=VALUE

If NAME is unset, set it to VALUE. Otherwise leave unchanged.

### 7.2 Eager binding

    NAME=VALUE

Always sets NAME to VALUE.

### 7.3 Positional argument

Any line not matching the above, or with `=` in `<metachars>`, becomes a positional argument.

---

## 8. Script Path Handling

By default, the script filename is appended as the final positional argument.

If any argument contains `${}`, this behaviour is disabled.

---

## 9. Execution

Construct:

- argv[0] = `<executable>`
- argv[1..N] = positional arguments
- optionally argv[N+1] = script filename

Construct envp[] from inherited environment plus bindings.

Then:

    execve(executable, argv, envp)

---

## 10. Error Conditions

runscript must fail if:

- `${NAME}` references an undefined variable
- the shebang is malformed
- header syntax is invalid
- the target executable cannot be invoked
